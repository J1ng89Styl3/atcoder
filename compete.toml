# Path to the test file (Liquid template)
#
# Variables:
#
# - `manifest_dir`: Package directory
# - `contest`:      Contest ID (e.g. "abc100")
# - `bin_name`:     Name of a `bin` target (e.g. "abc100-a")
# - `bin_alias`:    "Alias" for a `bin` target defined in `pacakge.metadata.cargo-compete` (e.g. "a")
# - `problem`:      Alias for `bin_alias` (deprecated)
#
# Additional filters:
#
# - `kebabcase`: Convert to kebab case (by using the `heck` crate)
test-suite = "{{ manifest_dir }}/testcases/{{ bin_alias }}.yml"

# Open files with the command (`jq` command that outputs `string[] | string[][]`)
#
# VSCode:
#open = '[["code", "-a", .manifest_dir], ["code"] + (.paths | map([.src, .test_suite]) | flatten)]'
# Emacs:
#open = '["emacsclient", "-n"] + (.paths | map([.src, .test_suite]) | flatten)]'

[template]
src = '''
#[warn(unused_imports)]
use std::iter::FromIterator;
use std::usize;
use ascii::Chars;
use bitvec::vec;
use im_rc::hashmap::Values;
use im_rc::{hashmap, HashSet};
use indexing::container_traits::FixedLength;
use num::abs;
use petgraph::visit::GraphProp;
use proconio::input;
use proconio::{marker::*, *};
use ac_library::*;
use proconio::marker::Usize1;
use std::collections::VecDeque;
use std::cmp;
use ac_library::Dsu;
use ac_library::SccGraph;
use std::collections::HashMap;
use std::collections::BinaryHeap;
use std::cmp::Reverse;
use superslice::*;
use itertools::{Itertools, Update};
use num::Integer;
use std::process::exit;
use ac_library::ModInt998244353 as Mint;
use std::collections::BTreeMap;
use ac_library::Segtree;
use fixedbitset::FixedBitSet;
use bitvec::prelude::*;
use std::collections::BTreeSet;
use itertools::iproduct;
use ac_library::modint::ModInt;

const INF: f64 = f64::INFINITY;
const NEG_INF: f64 = -f64::INFINITY;

// フェニック木
/*
""""""
使い方（0-indexed）
- Fenwick::new(n)
- add(i, v): 点iに+v（加算）
- sum(r): [1..r) ではなく、内部はBITなので呼び出しは prefix 用に sum(idx) を使う（この実装では idx は1-origin想定で呼ぶ）
  例: 区間[0, r) の和が欲しいとき -> sum(r)
""""""
*/
struct Fenwick {
    n: usize,
    bit: Vec<usize>,
}
impl Fenwick {
    fn new(n: usize) -> Self {
        Fenwick { n, bit: vec![0; n + 1] }
    }

    fn add(&mut self, idx: usize, v: usize) {
        let mut i = idx + 1;
        while i <= self.n {
            self.bit[i] += v;
            i += i & i.wrapping_neg();
        }
    }

    fn sum(&self, mut idx: usize) -> usize {
        let mut s = 0;
        while idx > 0 {
            s += self.bit[idx];
            idx -= idx & idx.wrapping_neg();
        }
        s
    }
}

// セグ木
/*
""""""
使い方（0-indexed, 半開区間）
- SegmentTree::new(n) or SegmentTree::from_vec(&values)
- set(i, v) / update(i, v): 点代入
- add(i, delta): 点加算
- get(i) -> 値取得
- query(l, r) -> 区間和 [l, r)
メモ:
- 配列長nに対して内部は2n長の反復型。nは2の冪でなくてOK。
""""""
*/
struct SegmentTree {
    n: usize,
    tree: Vec<usize>,
}

impl SegmentTree {
    fn new(n: usize) -> Self {
        SegmentTree { n, tree: vec![0; n * 2] }
    }

    fn from_vec(values: &[usize]) -> Self {
        let n = values.len();
        let mut st = SegmentTree { n, tree: vec![0; n * 2] };
        st.tree[n..n + n].copy_from_slice(values);
        for i in (1..n).rev() {
            st.tree[i] = st.tree[i * 2] + st.tree[i * 2 + 1];
        }
        st
        }

    fn update(&mut self, idx: usize, v: usize) {
        let mut i = idx + self.n;
        self.tree[i] = v;
        while i > 1 {
            i >>= 1;
            self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1];
        }
    }

    fn set(&mut self, idx: usize, v: usize) {
        self.update(idx, v);
    }

    fn add(&mut self, idx: usize, delta: usize) {
        let cur = self.get(idx);
        self.update(idx, cur + delta);
    }

    fn get(&self, idx: usize) -> usize {
        self.tree[idx + self.n]
    }

    fn query(&self, mut l: usize, mut r: usize) -> usize {
        let mut left_sum = 0;
        let mut right_sum = 0;
        l += self.n;
        r += self.n;
        while l < r {
            if (l & 1) == 1 { left_sum += self.tree[l]; l += 1; }
            if (r & 1) == 1 { r -= 1; right_sum += self.tree[r]; }
            l >>= 1;
            r >>= 1;
        }
        left_sum + right_sum
    }

    fn len(&self) -> usize { self.n }
}

// 遅延セグ木
struct LazySegmentTree {
    n: usize,
    size: usize,
    tree: Vec<usize>,
    lazy: Vec<usize>,
}

impl LazySegmentTree {
    /*
    """"""
    使い方（0-indexed, 半開区間）
    - LazySegmentTree::new(n) or LazySegmentTree::from_vec(&values)
    - range_add(l, r, delta): 区間 [l, r) に +delta を加算
    - query(l, r) -> 区間和 [l, r)
    - get(i) -> 値取得（query(i, i+1)の糖衣）
    メモ:
    - 内部は次の2冪sizeに拡張。余り部分は0として扱う。
    - 和モノイド（加算）前提。min/max等にしたい場合は結合/遅延の定義を変更。
    """"""
    */
    fn new(n: usize) -> Self {
        let mut size = 1usize;
        while size < n { size <<= 1; }
        LazySegmentTree { n, size, tree: vec![0; size * 2], lazy: vec![0; size * 2] }
    }

    fn from_vec(values: &[usize]) -> Self {
        let n = values.len();
        let mut st = Self::new(n);
        for i in 0..n { st.tree[st.size + i] = values[i]; }
        for i in (1..st.size).rev() { st.tree[i] = st.tree[i * 2] + st.tree[i * 2 + 1]; }
        st
    }

    fn apply_node(&mut self, idx: usize, add: usize, len: usize) {
        if add == 0 { return; }
        self.tree[idx] += add * len;
        self.lazy[idx] += add;
    }

    fn push(&mut self, idx: usize, len: usize) {
        let add = self.lazy[idx];
        if add == 0 || len == 1 { return; }
        let half = len / 2;
        let left = idx * 2;
        let right = left + 1;
        self.apply_node(left, add, half);
        self.apply_node(right, add, half);
        self.lazy[idx] = 0;
    }

    fn range_add(&mut self, l: usize, r: usize, delta: usize) {
        self.range_add_inner(1, 0, self.size, l, r, delta);
    }

    fn range_add_inner(&mut self, idx: usize, nl: usize, nr: usize, l: usize, r: usize, delta: usize) {
        if r <= nl || nr <= l { return; }
        if l <= nl && nr <= r {
            self.apply_node(idx, delta, nr - nl);
            return;
        }
        self.push(idx, nr - nl);
        let mid = (nl + nr) / 2;
        self.range_add_inner(idx * 2, nl, mid, l, r, delta);
        self.range_add_inner(idx * 2 + 1, mid, nr, l, r, delta);
        self.tree[idx] = self.tree[idx * 2] + self.tree[idx * 2 + 1];
    }

    fn query(&mut self, l: usize, r: usize) -> usize {
        self.query_inner(1, 0, self.size, l, r)
    }

    fn query_inner(&mut self, idx: usize, nl: usize, nr: usize, l: usize, r: usize) -> usize {
        if r <= nl || nr <= l { return 0; }
        if l <= nl && nr <= r { return self.tree[idx]; }
        self.push(idx, nr - nl);
        let mid = (nl + nr) / 2;
        let left_sum = self.query_inner(idx * 2, nl, mid, l, r);
        let right_sum = self.query_inner(idx * 2 + 1, mid, nr, l, r);
        left_sum + right_sum
    }

    fn get(&mut self, i: usize) -> usize { self.query(i, i + 1) }
    fn len(&self) -> usize { self.n }
}

fn main() {
    
}
'''

[template.new]
edition = "2018"
dependencies = '''
ac-library-rs = "=0.1.1"
once_cell = "=1.18.0"
static_assertions = "=1.1.0"
varisat = "=0.2.2"
memoise = "=0.3.2"
argio = "=0.2.0"
bitvec = "=1.0.1"
counter = "=0.5.7"
hashbag = "=0.1.11"
pathfinding = "=4.3.0"
recur-fn = "=2.2.0"
indexing = "=0.4.1"
amplify = "=3.14.2"
amplify_derive = "=2.11.3"
amplify_num = "=0.4.1"
easy-ext = "=1.0.1"
multimap = "=0.9.0"
btreemultimap = "=0.1.1"
bstr = "=1.6.0"
az = "=1.2.1"
glidesort = "=0.1.2"
tap = "=1.0.1"
omniswap = "=0.1.0"
multiversion = "=0.7.2"
num = "=0.4.1"
num-bigint = "=0.4.3"
num-complex = "=0.4.3"
num-integer = "=0.1.45"
num-iter = "=0.1.43"
num-rational = "=0.4.1"
num-traits = "=0.2.15"
num-derive = "=0.4.0"
ndarray = "=0.15.6"
nalgebra = "=0.32.3"
alga = "=0.9.3"
libm = "=0.2.7"
rand = "=0.8.5"
getrandom = "=0.2.10"
rand_chacha = "=0.3.1"
rand_core = "=0.6.4"
rand_hc = "=0.3.2"
rand_pcg = "=0.3.1"
rand_distr = "=0.4.3"
petgraph = "=0.6.3"
indexmap = "=2.0.0"
regex = "=1.9.1"
lazy_static = "=1.4.0"
ordered-float = "=3.7.0"
ascii = "=1.1.0"
permutohedron = "=0.2.4"
superslice = "=1.0.0"
itertools = "=0.11.0"
itertools-num = "=0.1.3"
maplit = "=1.0.2"
either = "=1.8.1"
im-rc = "=15.1.0"
fixedbitset = "=0.4.2"
bitset-fixed = "=0.1.0"
proconio = { version = "=0.4.5", features = ["derive"] }
text_io = "=0.1.12"
rustc-hash = "=1.1.0"
smallvec = "=1.11.0"
'''
dev-dependencies = '''
#atcoder-202004-lock = { git = "https://github.com/qryxip/atcoder-202004-lock" }
'''

[template.new.copy-files]
"./template-cargo-lock.toml" = "Cargo.lock"

[new]
kind = "cargo-compete"
# Platform
#
# - atcoder
# - codeforces
# - yukicoder
platform = "atcoder"
# Path (Liquid template)
#
# Variables:
#
# - `contest`:      Contest ID. **May be nil**
# - `package_name`: Package name
path = "./{{ contest }}"

#[new]
#kind = "oj-api"
#url = "https://atcoder.jp/contests/{{ id }}"
#path = "./{{ contest }}"

# for Library-Checker
#[add]
#url = "https://judge.yosupo.jp/problem/{{ args[0] }}"
##is-contest = ["false"] # optional
##target-kind = "bin" # ["bin", "example"]. default to "bin"
#bin-name = '{{ args[0] }}'
##bin-alias = '{{ args[0] }}' # optional
##bin-src-path = './src/bin/{{ bin_alias }}.rs' # optional

# for yukicoder
#[add]
#url = '{% case args[0] %}{% when "contest" %}https://yukicoder.me/contests/{{ args[1] }}{% when "problem" %}https://yukicoder.me/problems/no/{{ args[1] }}{% endcase %}'
#is-contest = ["bash", "-c", '[[ $(cut -d / -f 4) == "contests" ]]'] # optional
##target-kind = "bin" # ["bin", "example"]. default to "bin"
#bin-name = '{% assign segments = url | split: "/" %}{{ segments[5] }}'
##bin-alias = '{% assign segments = url | split: "/" %}{{ segments[5] }}' # optional
##bin-src-path = './src/bin/{{ bin_alias }}.rs' # optional

[test]
# Toolchain for the test. (optional)
toolchain = "1.70.0"
# Profile for `cargo build`. ("dev" | "release")
#
# Defaults to `"dev"`.
#profile = "dev"

[submit]
kind = "file"
path = "{{ src_path }}"
language_id = "5040"
#[submit]
#kind = "command"
#args = ["cargo", "equip", "--exclude-atcoder-crates", "--resolve-cfgs", "--remove", "docs", "--minify", "libs", "--rustfmt", "--check", "--bin", "{{ bin_name }}"]
#language_id = "4050"